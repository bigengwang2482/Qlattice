[
 [
  "Expr([Term([],[],1)],'(1)')"
 ],
 [
  "Expr([Term([],[Qv('u','x1','s1','c1'), Qb('u','x2','s2','c2')],1)],\"Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2')\")"
 ],
 [
  "Expr([Term([],[Qv('u','x1','s1','c1'), Qb('u','x2','s2','c2')],1), Term([],[Qb('u','x2','s2','c2'), Qv('u','x1','s1','c1')],1)],\"+Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1')\")"
 ],
 [
  "Expr([Term([],[],1)],'< (1) >')"
 ],
 [
  "Expr([Term([Chain([S('l','x1','x2')],'sc','s1','s2','c1','c2')],[],1)],\"< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') >\")"
 ],
 [
  "Expr([],\"< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1') >\")"
 ],
 [
  "# Begin CExpr\ndiagram_type_dict = dict()\ndiagram_type_dict[()] = 'ADT0'\ndiagram_type_dict[((('x1', 'x2'), 1),)] = 'ADT1'\n# Positions:\nx1, x2 = ['x1', 'x2']\n# Diagram type coef:\ncoef_ADT0                      = 1\ncoef_ADT1                      = 1\n# Named terms:\nterm_ADT0_0                    = coef_ADT0 * \nterm_ADT1_0                    = coef_ADT1 * chain(S_l(x1,x2))\nterms = [ 0 for i in range(2) ]\nterms[0] = term_ADT0_0\nterms[1] = term_ADT1_0\n# Named exprs:\nexprs = [ 0 for i in range(3) ]\n# < (1) >  exprs[0]\nexprs[0] += 1*term_ADT0_0\n# < Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') >  exprs[1]\nexprs[1] += 1*term_ADT1_0\n# < Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1') >  exprs[2]\n# End CExpr"
 ],
 [
  "[('ADT0', ()), ('ADT1', ((('x1', 'x2'), 1),))]"
 ],
 [
  "['x1', 'x2']"
 ],
 [
  "[]"
 ],
 [
  "[]"
 ],
 [
  "[]"
 ],
 [
  "[]"
 ],
 [
  "[]"
 ],
 [
  "[]"
 ],
 [
  "[]"
 ],
 [
  "[]"
 ],
 [
  "[('term_ADT0_0', Term([],[],1)), ('term_ADT1_0', Term([Chain([S('l','x1','x2')],'sc','s1','s2','c1','c2')],[],1))]"
 ],
 [
  "[('< (1) >  exprs[0]', [(1, 'term_ADT0_0')]), (\"< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') >  exprs[1]\", [(1, 'term_ADT1_0')]), (\"< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1') >  exprs[2]\", [])]"
 ],
 [
  "diagram_type_dict = qac.get_diagram_type_dict(cexpr)"
 ],
 [
  "diagram_type_dict[()] = 'ADT0'"
 ],
 [
  "diagram_type_dict[((('x1', 'x2'), 1),)] = 'ADT1'"
 ],
 [
  "qac.get_expr_names(cexpr)"
 ],
 [
  "< (1) >  exprs[0]"
 ],
 [
  "< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') >  exprs[1]"
 ],
 [
  "< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1') >  exprs[2]"
 ],
 [
  "# Begin CExpr\ndiagram_type_dict = dict()\ndiagram_type_dict[()] = 'ADT0'\ndiagram_type_dict[((('x1', 'x2'), 1),)] = 'ADT1'\n# Positions:\nx1, x2 = ['x1', 'x2']\n# Variables prop:\nV_S_0                          = S_l(x1,x2)\n# Variables factor:\nV_factor_final_0               = 1\n# Variables chain:\nV_chain_0                      = chain(V_S_0)\n# Diagram type coef:\ncoef_ADT0                      = 1\ncoef_ADT1                      = 1\n# Named terms:\nterm_ADT0_0                    = coef_ADT0 * \nterm_ADT1_0                    = coef_ADT1 * V_chain_0\nterms = [ 0 for i in range(2) ]\nterms[0] = term_ADT0_0\nterms[1] = term_ADT1_0\n# Named exprs:\nexprs = [ 0 for i in range(3) ]\n# < (1) >  exprs[0]\nexprs[0] += (V_factor_final_0)*term_ADT0_0\n# < Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') >  exprs[1]\nexprs[1] += (V_factor_final_0)*term_ADT1_0\n# < Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1') >  exprs[2]\n# End CExpr"
 ],
 [
  "[('ADT0', ()), ('ADT1', ((('x1', 'x2'), 1),))]"
 ],
 [
  "['x1', 'x2']"
 ],
 [
  "[]"
 ],
 [
  "[('V_factor_final_0', ea.Expr([ea.Term([],1)]))]"
 ],
 [
  "[('V_S_0', S('l','x1','x2'))]"
 ],
 [
  "[]"
 ],
 [
  "[]"
 ],
 [
  "[('V_chain_0', Chain([Var('V_S_0')],'sc','s1','s2','c1','c2'))]"
 ],
 [
  "[]"
 ],
 [
  "[]"
 ],
 [
  "[('term_ADT0_0', Term([],[],1)), ('term_ADT1_0', Term([Var('V_chain_0')],[],1))]"
 ],
 [
  "[('< (1) >  exprs[0]', [(ea.Expr([ea.Term([ea.Factor(V_factor_final_0,[],Var)],1)]), 'term_ADT0_0')]), (\"< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') >  exprs[1]\", [(ea.Expr([ea.Term([ea.Factor(V_factor_final_0,[],Var)],1)]), 'term_ADT1_0')]), (\"< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1') >  exprs[2]\", [])]"
 ],
 [
  "diagram_type_dict = qac.get_diagram_type_dict(cexpr_opt)"
 ],
 [
  "diagram_type_dict[()] = 'ADT0'"
 ],
 [
  "diagram_type_dict[((('x1', 'x2'), 1),)] = 'ADT1'"
 ],
 [
  "qac.get_expr_names(cexpr_opt)"
 ],
 [
  "< (1) >  exprs[0]"
 ],
 [
  "< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') >  exprs[1]"
 ],
 [
  "< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1') >  exprs[2]"
 ],
 [
  "from auto_contractor.runtime import *\n\n### ----\n\n@timer\ndef cexpr_function(*, positions_dict, get_prop, is_ama_and_sloppy=False):\n    # get_props\n    props, cms, factors = cexpr_function_get_prop(positions_dict, get_prop)\n    # eval\n    ama_val = cexpr_function_eval(positions_dict, props, cms, factors)\n    # extract sloppy val\n    val_sloppy = ama_extract(ama_val, is_sloppy=True)\n    # extract AMA val\n    val_ama = ama_extract(ama_val)\n    # return\n    if is_ama_and_sloppy:\n        # return both AMA corrected results and sloppy results\n        return val_ama, val_sloppy\n    else:\n        # return AMA corrected results by default\n        return val_ama\n\n### ----\n\n@timer_flops\ndef cexpr_function_get_prop(positions_dict, get_prop):\n    # set positions\n    x1 = positions_dict['x1']\n    x2 = positions_dict['x2']\n    # get prop\n    V_S_0 = get_prop('l', x1, x2)\n    # get color matrix\n    # set props for return\n    props = [\n        V_S_0,\n        ]\n    # set color matrix for return\n    cms = [\n        ]\n    # set intermediate factors\n    # declare factors\n    factors = np.zeros(1, dtype=np.complex128)\n    factors_view = factors # Python only\n    # set factors\n    # V_factor_final_0\n    V_factor_final_0 = (1) # Python only\n    factors_view[0] = V_factor_final_0\n    # set flops\n    total_flops = len(props) * 144 * 2 * 8 + len(cms) * 9 * 2 * 8 + len(factors) * 2 * 8\n    # return\n    return total_flops, (props, cms, factors,)\n\n### ----\n\n@timer_flops\ndef cexpr_function_eval(positions_dict, props, cms, factors):\n    # load AMA props with proper format\n    props = [ load_prop(p) for p in props ]\n    # join the AMA props\n    ama_props = ama_list(*props)\n    # apply eval to the factors and AMA props\n    ama_val = ama_apply1(lambda x_props: cexpr_function_eval_with_props(positions_dict, x_props, cms, factors), ama_props)\n    # set flops\n    total_flops = ama_counts(ama_val) * total_sloppy_flops\n    # return\n    return total_flops, ama_val\n\n### ----\n\n@timer_flops\ndef cexpr_function_eval_with_props(positions_dict, props, cms, factors_view): # Python only\n    # set positions\n    x1 = positions_dict['x1']\n    x2 = positions_dict['x2']\n    # set props\n    p_V_S_0 = props[0] # Python only\n    # set cms\n    # set factors\n    V_factor_final_0 = factors_view[0] # Python only\n    # compute products\n    # compute chains\n    V_chain_0 = p_V_S_0 # Python only\n    # compute traces\n    # compute baryon_props\n    # set terms\n    term_ADT0_0 = 1 # Python only\n    term_ADT1_0 = V_chain_0 # Python only\n    # declare exprs\n    exprs = np.empty(3, dtype=object)\n    exprs_view = exprs\n    # set exprs\n    expr_V_G = SpinMatrix() # Python only\n    expr_V_S = WilsonMatrix() # Python only\n    expr_V_U = ColorMatrix() # Python only\n    # 0 name='< (1) >  exprs[0]' \n    expr_V_a = 0\n    expr_V_a += (((V_factor_final_0))) * term_ADT0_0\n    exprs_view[0] = expr_V_a # Python only\n    # 1 name='< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') >  exprs[1]' \n    expr_V_S.set_zero() # Python only\n    expr_V_S += mat_mul_a_wm(((V_factor_final_0)), term_ADT1_0)\n    exprs_view[1] = expr_V_S.copy() # Python only\n    # 2 name='< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1') >  exprs[2]' \n    exprs_view[2] = 0\n    # set flops\n    total_flops = total_sloppy_flops\n    # return\n    return total_flops, exprs\n\n### ----\n\n\n### ----\n\n# Total flops per sloppy call is: 0\ntotal_sloppy_flops = 0"
 ],
 [
  "diagram_type_dict = qac.get_diagram_type_dict(ccexpr)"
 ],
 [
  "diagram_type_dict[()] = 'ADT0'"
 ],
 [
  "diagram_type_dict[((('x1', 'x2'), 1),)] = 'ADT1'"
 ],
 [
  "qac.get_expr_names(ccexpr)"
 ],
 [
  "< (1) >  exprs[0]"
 ],
 [
  "< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') >  exprs[1]"
 ],
 [
  "< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1') >  exprs[2]"
 ],
 [
  "get_cexpr_test benchmark_eval_cexpr check get_data_sig is_cython=False",
  {
   "real": -0.8221798433269569,
   "imag": 12.522383950798009,
   "__extended_json_type__": "complex128"
  }
 ],
 [
  "get_cexpr_test benchmark_eval_cexpr check_ama get_data_sig is_cython=False",
  {
   "real": 3.2178849968989516,
   "imag": -19.122790847538006,
   "__extended_json_type__": "complex128"
  }
 ],
 [
  "from auto_contractor.runtime import *\nimport cython # Cython\ncimport qlat_utils.everything as cc # Cython\ncimport qlat_utils.all as qu # Cython\ncimport libcpp.complex # Cython\ncimport numpy # Cython\n\n### ----\n\n@timer\ndef cexpr_function(*, positions_dict, get_prop, is_ama_and_sloppy=False):\n    # get_props\n    props, cms, factors = cexpr_function_get_prop(positions_dict, get_prop)\n    # eval\n    ama_val = cexpr_function_eval(positions_dict, props, cms, factors)\n    # extract sloppy val\n    val_sloppy = ama_extract(ama_val, is_sloppy=True)\n    # extract AMA val\n    val_ama = ama_extract(ama_val)\n    # return\n    if is_ama_and_sloppy:\n        # return both AMA corrected results and sloppy results\n        return val_ama, val_sloppy\n    else:\n        # return AMA corrected results by default\n        return val_ama\n\n### ----\n\n@timer_flops\n@cython.boundscheck(False) # Cython\n@cython.wraparound(False) # Cython\ndef cexpr_function_get_prop(positions_dict, get_prop):\n    # set positions\n    x1 = positions_dict['x1']\n    x2 = positions_dict['x2']\n    # get prop\n    V_S_0 = get_prop('l', x1, x2)\n    # get color matrix\n    # set props for return\n    props = [\n        V_S_0,\n        ]\n    # set color matrix for return\n    cms = [\n        ]\n    # set intermediate factors\n    # declare factors\n    cdef numpy.ndarray[numpy.complex128_t] factors # Cython\n    factors = np.zeros(1, dtype=np.complex128)\n    cdef cc.PyComplexD[:] factors_view = factors # Cython\n    # set factors\n    # V_factor_final_0\n    cdef cc.PyComplexD V_factor_final_0 = (1) # Cython\n    factors_view[0] = V_factor_final_0\n    # set flops\n    total_flops = len(props) * 144 * 2 * 8 + len(cms) * 9 * 2 * 8 + len(factors) * 2 * 8\n    # return\n    return total_flops, (props, cms, factors,)\n\n### ----\n\n@timer_flops\ndef cexpr_function_eval(positions_dict, props, cms, factors):\n    # load AMA props with proper format\n    props = [ load_prop(p) for p in props ]\n    # join the AMA props\n    ama_props = ama_list(*props)\n    # apply eval to the factors and AMA props\n    ama_val = ama_apply1(lambda x_props: cexpr_function_eval_with_props(positions_dict, x_props, cms, factors), ama_props)\n    # set flops\n    total_flops = ama_counts(ama_val) * total_sloppy_flops\n    # return\n    return total_flops, ama_val\n\n### ----\n\n@timer_flops\n@cython.boundscheck(False) # Cython\n@cython.wraparound(False) # Cython\ndef cexpr_function_eval_with_props(dict positions_dict, list props, list cms, cc.PyComplexD[:] factors_view): # Cython\n    # set positions\n    x1 = positions_dict['x1']\n    x2 = positions_dict['x2']\n    # set props\n    cdef cc.WilsonMatrix* p_V_S_0 = &(<qu.WilsonMatrix>props[0]).xx # Cython\n    # set cms\n    # set factors\n    cdef cc.PyComplexD V_factor_final_0 = factors_view[0] # Cython\n    # compute products\n    # compute chains\n    cdef cc.WilsonMatrix V_chain_0 = p_V_S_0[0] # Cython\n    # compute traces\n    # compute baryon_props\n    # set terms\n    cdef cc.PyComplexD term_ADT0_0 = 1 # Cython\n    cdef cc.WilsonMatrix term_ADT1_0 = V_chain_0 # Cython\n    # declare exprs\n    exprs = np.empty(3, dtype=object)\n    exprs_view = exprs\n    # set exprs\n    cdef cc.PyComplexD expr_V_a # Cython\n    cdef cc.SpinMatrix expr_V_G # Cython\n    cdef cc.WilsonMatrix expr_V_S # Cython\n    cdef cc.ColorMatrix expr_V_U # Cython\n    cdef qu.SpinMatrix expr_V_G_box # Cython\n    cdef qu.WilsonMatrix expr_V_S_box # Cython\n    cdef qu.ColorMatrix expr_V_U_box # Cython\n    # 0 name='< (1) >  exprs[0]' \n    expr_V_a = 0\n    expr_V_a += (((V_factor_final_0))) * term_ADT0_0\n    exprs_view[0] = expr_V_a # Cython\n    # 1 name='< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') >  exprs[1]' \n    cc.set_zero(expr_V_S) # Cython\n    expr_V_S += cc.ccpy_d(((V_factor_final_0))) * term_ADT1_0\n    expr_V_S_box = WilsonMatrix() # Cython\n    expr_V_S_box.xx = expr_V_S # Cython\n    exprs_view[1] = expr_V_S_box # Cython\n    # 2 name='< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1') >  exprs[2]' \n    exprs_view[2] = 0\n    # set flops\n    total_flops = total_sloppy_flops\n    # return\n    return total_flops, exprs\n\n### ----\n\n\n### ----\n\n# Total flops per sloppy call is: 0\ntotal_sloppy_flops = 0"
 ],
 [
  "diagram_type_dict = qac.get_diagram_type_dict(ccexpr)"
 ],
 [
  "diagram_type_dict[()] = 'ADT0'"
 ],
 [
  "diagram_type_dict[((('x1', 'x2'), 1),)] = 'ADT1'"
 ],
 [
  "qac.get_expr_names(ccexpr)"
 ],
 [
  "< (1) >  exprs[0]"
 ],
 [
  "< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') >  exprs[1]"
 ],
 [
  "< Qv('u','x1','s1','c1') * Qb('u','x2','s2','c2') + Qb('u','x2','s2','c2') * Qv('u','x1','s1','c1') >  exprs[2]"
 ],
 [
  "get_cexpr_test benchmark_eval_cexpr check get_data_sig is_cython=True",
  {
   "real": -0.8221798433269569,
   "imag": 12.522383950798009,
   "__extended_json_type__": "complex128"
  }
 ],
 [
  "get_cexpr_test benchmark_eval_cexpr check_ama get_data_sig is_cython=True",
  {
   "real": 3.2178849968989516,
   "imag": -19.122790847538006,
   "__extended_json_type__": "complex128"
  }
 ],
 [
  "get_prop wm",
  {
   "real": 0.7479361264365885,
   "imag": 3.7221107753466054,
   "__extended_json_type__": "complex128"
  }
 ],
 [
  "eval_cexpr res[0]",
  {
   "real": 1.0,
   "imag": 0.0,
   "__extended_json_type__": "complex"
  }
 ],
 [
  "eval_cexpr res[1]",
  {
   "real": 0.7479361264365885,
   "imag": 3.7221107753466054,
   "__extended_json_type__": "complex128"
  }
 ],
 [
  "eval_cexpr res[2]",
  {
   "real": 0.0,
   "imag": 0.0,
   "__extended_json_type__": "complex"
  }
 ]
]