qlat_utils
==========

.. automodule:: qlat_utils
   :members:

Message
-------

.. autosummary::
   :toctree: generated
 
   verbose_level

   displayln
   displayln_info

   get_fname

Timer
-----

.. autosummary::
   :toctree: generated

   timer
   timer_verbose
   timer_flops
   timer_verbose_flops

   timer_display
   timer_display_stack

   timer_fork
   timer_merge

   get_time
   get_start_time

Random number
-------------

.. autosummary::
   :toctree: generated

   RngState
   get_double_sig

Algorithm of the random number generator
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The state of the generator is effectively composed of the history of the generator encoded as a string.

To generate random numbers, one computes the SHA-256 hash of the string.  The hash result is viewed as a `8` 32-bit unsigned integers.

The ``8`` 32-bit unsigned integers are merged into ``4`` 64-bit unsigned integers. These ``4`` numbers are treated as the random numbers generated by this random number generator.

Relevant source files: ``qlat-utils/include/qlat-utils/rng-state.h`` and ``qlat-utils/lib/rng-state.cpp``

QAR and IO
----------

.. autosummary::
   :toctree: generated

   list_qar
   qar_create_info
   qar_extract_info
   get_qar_multi_vol_max_size
   qcat
   qcat_bytes
   qcopy_file_info
   does_file_exist
   does_file_exist_qar
   does_regular_file_exist_qar

LatData
-------

Multi-dimension array data structure for IO.

.. autosummary::
   :recursive:
   :toctree: generated

   LatData
   LatData.info
   LatData.set_info
   LatData.to_numpy
   LatData.from_numpy
   mk_lat_data
   load_lat_data

Coordinate
----------

.. autosummary::
   :toctree: generated

   rel_mod
   rel_mod_sym

   rel_mod_arr
   rel_mod_sym_arr

   Coordinate
   Coordinate.list
   Coordinate.sqr

Cache system
------------

.. autosummary::
   :toctree: generated

   Cache
   mk_cache
   clean_cache
   list_cache
   rm_cache
   get_all_caches_info
   clear_all_caches

Example code::

    Usage:
    cache_x = q.mk_cache("xx")
    q.clean_cache(cache_x)
    cache_x[key] = value
    val = cache_x[key]
    key in cache_x
    val = cache_x.get(key)
    val = cache_x.pop(key, None)

Matrix for QCD
--------------

.. autosummary::
   :toctree: generated

   WilsonMatrix
   SpinMatrix

   as_wilson_matrix
   as_wilson_matrix_g5_herm

ElemType
--------

.. autosummary::
   :toctree: generated

   ElemType
   ElemTypeChar
   ElemTypeInt8t
   ElemTypeInt64t
   ElemTypeLong
   ElemTypeDouble
   ElemTypeFloat
   ElemTypeComplex
   ElemTypeComplexF

   ElemTypeSpinMatrix
   ElemTypeWilsonMatrix
   ElemTypeColorMatrix
   ElemTypeIsospinMatrix
   ElemTypeNonRelWilsonMatrix
   ElemTypeWilsonVector

Data analysis
-------------

Spatial distance list
^^^^^^^^^^^^^^^^^^^^^

.. autosummary::
   :toctree: generated

   mk_r_sq_list
   mk_r_list
   mk_interp_tuple
   mk_r_sq_interp_idx_coef_list

Jackknife method
^^^^^^^^^^^^^^^^

.. autosummary::
   :toctree: generated

   g_jk
   g_rejk
   g_mk_jk_val
   g_jk_avg
   g_jk_err
   g_jk_avg_err
   g_jk_size
   g_jk_blocking_func

Example code that uses the randomized Super-Jackknife method::

    import qlat_utils as q
    import numpy as np

    q.default_g_jk_kwargs["jk_type"] = "rjk"
    q.default_g_jk_kwargs["n_rand_sample"] = 1024
    q.default_g_jk_kwargs["rng_state"] = q.RngState("rejk")

    rs = q.RngState("seed")
    job_tag = "test"
    trajs = range(25)

    data_list = np.zeros((len(trajs), 5,)) # can be list or np.array
    rs.g_rand_fill(data_list)
    jk_list = q.g_jk(data_list)
    jk_idx_list = [ "avg", ] + [ (job_tag, traj) for traj in trajs ]
    jk_list = q.g_rejk(jk_list, jk_idx_list)
    avg, err = q.g_jk_avg_err(jk_list)

    print(avg)
    print(err)

Example code that uses the conventional Super-Jackknife method::

    import qlat_utils as q
    import numpy as np

    def get_all_jk_idx():
        all_job_tag = [ 'test1', 'test2', ]
        jk_idx_list = [ 'avg', ]
        for job_tag in all_job_tag:
            trajs = get_trajs(job_tag)
            for traj in trajs:
                jk_idx_list.append((job_tag, traj,))
        return jk_idx_list

    q.default_g_jk_kwargs["get_all_jk_idx"] = get_all_jk_idx
    q.default_g_jk_kwargs["jk_type"] = "super"

    def get_trajs(job_tag):
        return list(range(25))

    rs = q.RngState("seed")
    job_tag = "test1"
    trajs = list(range(25))

    data_list = np.zeros((len(trajs), 5,)) # can be list or np.array
    rs.g_rand_fill(data_list)
    jk_list = q.g_jk(data_list)
    jk_idx_list = [ "avg", ] + [ (job_tag, traj) for traj in trajs ]
    jk_list = q.g_rejk(jk_list, jk_idx_list)
    avg, err = q.g_jk_avg_err(jk_list)

    print(avg)
    print(err)

Plotting
^^^^^^^^

.. autosummary::
   :toctree: generated

   plot_save
   plot_view
